# -*- coding: utf-8 -*-
"""Recommendation_System_Ali_Dicod.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_WQEN0TqY6AiXDNHkbLbkZqPOKWInQfL

# **Submission Project**

---

# OVERVIEW

Bengaluru adalah tempat terbaik untuk pecinta kuliner. Jumlah restoran semakin hari semakin bertambah. Saat ini yang berdiri di sekitar 12.000 restoran. Dengan jumlah restoran yang begitu tinggi. Industri ini belum jenuh. Dan restoran baru buka setiap hari. Namun menjadi sulit bagi mereka untuk bersaing dengan restoran yang sudah mapan. Dataset ini bertujuan untuk menganalisis demografi lokasi dari sebuah resto. Yang paling penting itu akan membantu restoran baru dalam menentukan tema, menu, masakan dll untuk lokasi tertentu. Ini juga bertujuan untuk menemukan kesamaan antara lingkungan Bengaluru berdasarkan makanan.

Dataset diambil dari https://www.kaggle.com/datasets/himanshupoddar/zomato-bangalore-restaurants

# IMPORT PACKAGES
"""

!pip install implicit

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from google.colab import drive
import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import implicit

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import r2_score
import warnings
warnings.filterwarnings('always')
warnings.filterwarnings('ignore')
import re
from nltk.corpus import stopwords
from sklearn.metrics.pairwise import linear_kernel
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfVectorizer
import nltk
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler

"""# READ DATASET"""

drive.mount('/content/gdrive')

df = pd.read_csv('/content/gdrive/MyDrive/Narasio/SNS/Capstone/zomato.csv')
df.head()

"""## Metadata

Berikut adalah deskripsi tiap kolom yang ada dari dataset

| Nama Kolom | Deskripsi |
| --- | --- |
|url|url resto|
|alamat|Alamat resto|
|nama|Nama resto|
|pesan_online|Pelayanan pembelian secara online|
|pesan_meja| Pelayanan pembelian meja|
|rating |Rata-rata rating resto|
|votes |Banyaknya rating yang diberikan pelanggan|
|telepon Nomor| telepon resto|
|lokasi |Lokasi resto|
|tipe_resto| Tipe resto|
|menu_favorit| Makanan yang paling disukai pelanggan|
|jenis_makanan| Jenis makanan di resto|
|dua_pelanggan| Banyaknya pelanggan yang memesan makanan untuk dua orang|
|review| Review pelanggan|
|menu| Menu di resto|
|tipe_makanan| Tipe makanan di resto|
|kota| Kota resto|

# PROBLEM STATEMENT

- Mendapatkan informasi behavior dari customer 
- Mempelajari demografi dari sebuah lokasi. Jenis makanan apa yang lebih populer di suatu daerah
- Membantu restoran baru dalam menentukan tema, menu dan masakan untuk lokasi tertentu untuk mendapatkan rekomendasi usaha kuliner apa yang sebaiknya dijalankan berdasar data yang ada

# DATA PRE-PROCESSING

## Data Understanding & Cleansing

- check data type format
- check for uniqueness
- check missing value
- check data value

### Function Data Understanding
"""

def listOfItem(data):
    list_Item = []
    for col in data.columns :
        list_Item.append([col, data[col].dtype,len(data), data[col].isna().sum(),data[col][data[col]=="\\N"].count(),data[col][data[col]=="0"].count(),round((data[col].isna().sum()/len(data[col])) * 100,2),
                        data[col].nunique()])

    dfDesc = pd.DataFrame(columns=['dataFeatures', 'dataType','Raw','missingValue','Nan(\\N) Value','Nol (0) Value','missingValue_Pct', 'uniqueValue'],
                        data=list_Item)
    return dfDesc

"""#### Analisa data"""

print("Dari hasil cheking ditemukan analisa sebagai berikut :"); 
listOfItem(df)

"""<b>Missing Value</b>

- Ada missing value pada kolom **rate**, namun dibiarkan karena bisa jadi restoran belum memiliki rata-rata rating
- Kolom **phone** ada missing value, tidak perlu dilakukan treatment karena asumsi lestoran hanya menerima pembelian dinein(tidak online order) sehingga tidak perlu memasang informasi nomor telp.
- Ada missing value pada **location**, hal ini perlu dikakukan drop missing value **(Dropna)**, karena setiap resto asumsi memiliki alamat
- **rest_type** ditemukan missing value, perlu dikakukan drop missing value **(Dropna)**
- **dish_liked** ditemukan missing value, perlu dikakukan drop missing value **(Dropna)**
- **cuisines ** ditemukan missing value, perlu dikakukan drop missing value **(Dropna)**
- **approx_cost(for two people)**	 ditemukan missing value, tidak perlu dikakukan drop missing value karena bisa jadi banyaknya pelanggan yang memesan makanan untuk dua orang tidak ada
- Pada kolom rate tipe data masih object, perlu dilakukan perubahan tipe data

##Data Preparation

### Data Cleansing Null Value
"""

def datanotnull(datasourcer,column):
    dataset = datasourcer.dropna(subset=column)
    return dataset

dataset = datanotnull(df,["location","rest_type","dish_liked","cuisines"])

print("Data setelah di cleansing"); 
listOfItem(dataset)

"""### Data Cleansing Anomaly

####Hapus data duplicated
"""

#Hapus data duplicated
dfresto = dataset.drop_duplicates()

dfresto.shape

dfresto.head()

"""#### Merapikan Kolom Dataset

#####Rubah nama kolom agar lebih rapih
"""

#Nama kolom perlu di rename agar lebih rapih
dfresto = dfresto.rename(columns={'approx_cost(for two people)':'cost','listed_in(type)':'type',
                                  'listed_in(city)':'city'})
dfresto.columns

"""#####Rubah tipe data yang sesuai"""

dfresto['cost'] = dfresto['cost'].astype(str) 
dfresto['cost'] = dfresto['cost'].apply(lambda x: x.replace(',','.'))
dfresto['cost'] = dfresto['cost'].astype(float)
dfresto.info()

"""#####Removing '/5' from Rates"""

dfresto = dfresto.loc[dfresto.rate !='NEW']
dfresto = dfresto.loc[dfresto.rate !='-'].reset_index(drop=True)
remove_slash = lambda x: x.replace('/5', '') if type(x) == np.str else x
dfresto.rate = dfresto.rate.apply(remove_slash).str.strip().astype('float')
dfresto['rate'].head()

dfresto.head()

"""##Univariate Data Analys

Meneliti distribusi rating dari rating dataframe dengan Barplot
"""

count = dfresto["rate"].value_counts()
count.plot(kind='bar', title="Rating");
 
plt.show()

"""## Multivariate Analysis

Melihat pairplot yang ada pada rating dataset
"""

sns.pairplot(dfresto, diag_kind = 'kde')



"""#EDA

### Customer Behavior
"""

dfresto.groupby(['online_order','book_table','location','rest_type','city']).agg({
    'name':lambda x:x.nunique()
}).sort_values('online_order', ascending=False)

"""####Onine VS Offline Order"""

f,ax = plt.subplots(1,1,figsize=(12,4))
countdfresto = dfresto['online_order'].value_counts()
colors = sns.color_palette('pastel')
countdfresto.plot.pie(explode=[0,0.1], autopct='%1.1f%%', shadow=True, colors=colors).set_title('Online Order?')
ax.set_ylabel('')
plt.show()

"""Sebanyak 70 persen customer lebih memilih order secara online dan sisanya offline"""

dfresto.groupby(['rest_type','online_order'])['name'].nunique().sort_values(ascending=False).head(10)

"""####Book Table Vs No"""

f,ax = plt.subplots(1,1,figsize=(12,4))
countdfresto = dfresto['book_table'].value_counts()
colors = sns.color_palette('pastel')
countdfresto.plot.pie(explode=[0,0.1], autopct='%1.1f%%', shadow=True, colors=colors).set_title('Book Table?')
ax.set_ylabel('')
plt.show()

"""Dari grafik dapat dilihat behavior customer lebih banyak yang pesan tanpa booking table terlebih dahulu

####Customer Order Behavior By Restoran Type
"""

dfresto.groupby(['rest_type','online_order'])['name'].nunique().sort_values(ascending=False).head(10).unstack().plot(kind='bar')
plt.title('Customer Order Behavior By Restoran Type',loc='center',pad=30,fontsize=15,color='blue')
plt.xlabel('Behavior',fontsize=15)
plt.ylabel('Total Transaksi',fontsize=15)
plt.ylim(ymin=0)
labels,location = plt.yticks()
plt.xticks(rotation=0)
plt.gcf().set_size_inches(10,5)
plt.show()

"""Secara keseluruhan Dari grafik dapat dilihat customer lebih banyak melakukan pembelian secara online sebanyak 69.2% dibanding offline sekitar 30.8 %, dan tipe restoran paling banyak disukai yaitu **Casual Dining**  kemudian disusul dengan **Quick Bites, Cafe dan Delivery.**

####Customer Order Offline dilihat dari Tipe Restoran
"""

dfresto[dfresto["online_order"]=="No"].groupby(['location','rest_type'])['name'].nunique().sort_values(ascending=False).head(10).unstack().plot(kind='bar')
plt.title('Customer Order Offline Untuk Tiap Tipe Restoran',loc='center',pad=30,fontsize=15,color='blue')
plt.xlabel('Behavior',fontsize=15)
plt.ylabel('Total Transaksi',fontsize=15)
plt.ylim(ymin=0)
labels,location = plt.yticks()
plt.xticks(rotation=0)
plt.gcf().set_size_inches(15,5)
plt.show()

"""Customer yang melakukan pembelian offline paling banyak berada di daerah **Whitefield,  Indiranagar,  JP Nagar, Marathalli dan Basavanaguni** dengan tipe restoran paling banyak adalah **Casual Dinning**

#### Customer Order Online dilihat dari Tipe Restoran
"""

dfresto[dfresto["online_order"]=="Yes"].groupby(['location','rest_type'])['name'].nunique().sort_values(ascending=False).head(10).unstack().plot(kind='bar')
plt.title('Customer Order Online',loc='center',pad=30,fontsize=15,color='blue')
plt.xlabel('Behavior',fontsize=15)
plt.ylabel('Total Transaksi',fontsize=15)
plt.ylim(ymin=0)
labels,location = plt.yticks()
plt.xticks(rotation=0)
plt.gcf().set_size_inches(15,5)
plt.show()

"""Customer yang melakukan pembelian online paling banyak berada di daerah **Whitefield, HSR, Indiranagar, BTM dan Marathalli** Dengan tipe restoran di dominasi oleh **Casual Dinning dan Quiq Bites**

####Food Type
"""

fig = plt.figure(figsize=(10,20))
ax1 = fig.add_subplot(1,1,1)
sns.countplot(y=dfresto['type'],ax=ax1,order = dfresto['type'].value_counts(ascending=False).index)

"""Customer paling sering melakukan delivery order

### Restorant Demografi

####Distribution of Location
"""

fig = plt.figure(figsize=(10,20))
ax1 = fig.add_subplot(1,1,1)
sns.countplot(y=dfresto['location'],ax=ax1,order = dfresto['location'].value_counts(ascending=False).index)
p = plt.xticks(rotation=30)

"""Customer membeli paling banyak di 3 lokasi yaitu Koramangala 5th Blovk,BTM dan indiranagar

####City Distribution
"""

fig = plt.figure(figsize=(10,20))
ax1 = fig.add_subplot(1,1,1)
sns.countplot(y=dfresto['city'],ax=ax1,order = dfresto['city'].value_counts(ascending=False).index)
p = plt.xticks(rotation=30)

"""Persebaran pembelian customer pada resto di 3 kota terbanyak yaitu di BTM, Koromangala 7th Block, Koromangala 4th Block"""

dfresto.info()

"""####Semua Distribusi Tipe Lestoran """

fig = plt.figure(figsize=(10,20))
ax1 = fig.add_subplot(1,1,1)
sns.countplot(y=dfresto['rest_type'],ax=ax1,order = dfresto['rest_type'].value_counts(ascending=False).index)

"""Customer paling banyak membeli pada Resto tipe Casual Dinning, Quiq bites dam cafe dilihat dari semua total pembelian pada tiap resto

###Rating Resto Per City
"""

dfresto.info()

fig = plt.figure(figsize=(15,20))
ax1 = fig.add_subplot(1,1,1)
sns.barplot(x='rate', y='city', data=dfresto,palette='rainbow',ax=ax1);

"""###Voting Resto per City"""

fig = plt.figure(figsize=(15,20))
ax1 = fig.add_subplot(1,1,1)
sns.barplot(x='votes', y='city', data=dfresto,palette='rainbow',ax=ax1);

"""# MODELING

##Content Filtered Recommendation System

Content Based Filtering adalah sistem rekomendasi yang merekomendasikan item sesuai dengan item yang disukai oleh pengguna di masa lampau.

Content Based mempelajari profil dan perilaku dari pengguna yang kemudian dari informasi tersebut dianalisa dan diproses sehingga menghasilkan sistem rekomendasi yang baik. Semakin banyak informasi yang diberikan ke sistem ini, maka sistem rekomendasi berbasis content based akan memiliki akurasi yang lebih baik.

**Tujuan dari projek ini  adalah membuat sistem pemberi rekomendasi berbasis konten di mana ketika user akan menulis nama restoran, sistem Rekomendasi akan melihat ulasan restoran lain, dan Sistem akan merekomendasikan kepada user restoran lain dengan ulasan serupa dan mengurutkannya dari peringkat tertinggi.**

####FEATURE ENGINEERING
"""

resto=dfresto.drop(['url','dish_liked','phone'],axis=1)

"""###Data Preparation

####Data Cleansing
"""

#Removing the Duplicates
resto.duplicated().sum()
resto.drop_duplicates(inplace=True)

#Remove the NaN values from the dataset
resto.isnull().sum()
resto.dropna(how='any',inplace=True)
resto.info()

#Some Transformations
resto['cost'] = resto['cost'].astype(str) #Changing the cost to string
resto['cost'] = resto['cost'].apply(lambda x: x.replace(',','.')) #Using lambda function to replace ',' from cost
resto['cost'] = resto['cost'].astype(float) # Changing the cost to Float
resto.info()

#Reading Rate of dataset
resto['rate'].unique()

resto = resto.loc[resto.rate !='NEW']
resto = resto.loc[resto.rate !='-'].reset_index(drop=True)
remove_slash = lambda x: x.replace('/5', '') if type(x) == np.str else x
resto['rate'] = resto['rate'].astype(float)
resto['rate'].head()

# Adjust the column names
resto.name = resto.name.apply(lambda x:x.title())
resto.online_order.replace(('Yes','No'),(True, False),inplace=True)
resto.book_table.replace(('Yes','No'),(True, False),inplace=True)
resto.cost.unique()

## Checking Null values
resto.isnull().sum()

## Computing Mean Rating
restaurants = list(resto['name'].unique())
resto['Mean Rating'] = 0

for i in range(len(restaurants)):
    resto['Mean Rating'][resto['name'] == restaurants[i]] = resto['rate'][resto['name'] == restaurants[i]].mean()

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range = (1,5))

resto[['Mean Rating']] = scaler.fit_transform(resto[['Mean Rating']]).round(2)

resto.sample(3)

"""#### Text Cleansing

- Lower casing
- Removal of Punctuations
- Removal of Stopwords
- Removal of URLs
- Spelling correction
"""

# 5 examples of these columns before text processing:
resto[['reviews_list', 'cuisines']].sample(5)

## Lower Casing
resto["reviews_list"] = resto["reviews_list"].str.lower()
resto[['reviews_list', 'cuisines']].sample(5)

## Removal of Puctuations
import string
PUNCT_TO_REMOVE = string.punctuation
def remove_punctuation(text):
    """custom function to remove the punctuation"""
    return text.translate(str.maketrans('', '', PUNCT_TO_REMOVE))

resto["reviews_list"] = resto["reviews_list"].apply(lambda text: remove_punctuation(text))
resto[['reviews_list', 'cuisines']].sample(5)

nltk.download('stopwords')

## Removal of Stopwords
from nltk.corpus import stopwords
STOPWORDS = set(stopwords.words('english'))
def remove_stopwords(text):
    """custom function to remove the stopwords"""
    return " ".join([word for word in str(text).split() if word not in STOPWORDS])

resto["reviews_list"] = resto["reviews_list"].apply(lambda text: remove_stopwords(text))

## Removal of URLS
def remove_urls(text):
    url_pattern = re.compile(r'https?://\S+|www\.\S+')
    return url_pattern.sub(r'', text)

resto["reviews_list"] = resto["reviews_list"].apply(lambda text: remove_urls(text))

resto[['reviews_list', 'cuisines']].sample(5)

# RESTAURANT NAMES:
restaurant_names = list(resto['name'].unique())
restaurant_names

def get_top_words(column, top_nu_of_words, nu_of_word):
    
    vec = CountVectorizer(ngram_range= nu_of_word, stop_words='english')
    
    bag_of_words = vec.fit_transform(column)
    
    sum_words = bag_of_words.sum(axis=0)
    
    words_freq = [(word, sum_words[0, idx]) for word, idx in vec.vocabulary_.items()]
    
    words_freq =sorted(words_freq, key = lambda x: x[1], reverse=True)
    
    return words_freq[:top_nu_of_words]

resto.shape

resto=resto.drop(['address','rest_type', 'type', 'menu_item', 'votes'],axis=1)

import pandas

# Randomly sample 60% of dataframe
df_percent = resto.sample(frac=0.5)

df_percent.shape

df_percent.head()

"""### Modeling

Pada content Based Filtering, kita akan menggunakan TF-IDF Vectorizer.

TF-IDF yang merupakan kepanjangan dari Term Frequency-Inverse Document Frequency memiliki fungsi untuk mengukur seberapa pentingnya suatu kata terhadap kata - kata lain dalam dokumen.
Kita umumnya menghitung skor untuk setiap kata untuk menandakan pentingnya dalam dokumen dan corpus. Metode sering digunakan dalam Information Retrieval dan Text Mining.
"""

df_percent.set_index('name', inplace=True)

indices = pd.Series(df_percent.index)

"""Kemudian kita akan lakukan fit dan transformasi ke dalam matriks, pada code di bawah ini, matriks tersebut adalah tfidf_matrix"""

# Creating tf-idf matrix
tfidf = TfidfVectorizer(analyzer='word', ngram_range=(1, 2), min_df=0, stop_words='english')
tfidf_matrix = tfidf.fit_transform(df_percent['reviews_list'])

tfidf_matrix.shape

"""Pada tfidf_matrix terdapat 11624 ukuran data dan 1161596 reviews_list

Dalam sistem rekomendasi, kita perlu mencari cara supaya item yang kita rekomendasikan tidak terlalu jauh dari data pusat, oleh karena itu kita butuh derajat kesamaan pada item, dalam proyek ini, resto dengan derajat kesamaan antar resto dengan cosine similarity
"""

#cosine_similarities = linear_kernel(tfidf_matrix, tfidf_matrix)

from sklearn.metrics.pairwise import cosine_similarity
 
cosine_sim = cosine_similarity(tfidf_matrix) 
cosine_sim

# HERE IS A RANDOM RESTAURANT. LET'S SEE THE DETAILS ABOUT THIS RESTAURANT:
df_percent[df_percent.index == 'Jalsa'].head()

"""Di bawah ini adalah fungsi untuk mendapatkan rekomendasi """

def recommend(name, cosine_similarities = cosine_sim):
    
    # Create a list to put top 10 restaurants
    recommend_restaurant = []
    
    # Find the index of the hotel entered
    idx = indices[indices == name].index[0]
    
    # Find the restaurants with a similar cosine-sim value and order them from bigges number
    score_series = pd.Series(cosine_similarities[idx]).sort_values(ascending=False)
    
    # Extract top 30 restaurant indexes with a similar cosine-sim value
    top30_indexes = list(score_series.iloc[0:31].index)
    
    # Names of the top 30 restaurants
    for each in top30_indexes:
        recommend_restaurant.append(list(df_percent.index)[each])
    
    # Creating the new data set to show similar restaurants
    df_new = pd.DataFrame(columns=['cuisines', 'Mean Rating', 'cost','location','city'])
    
    # Create the top 30 similar restaurants with some of their columns
    for each in recommend_restaurant:
        df_new = df_new.append(pd.DataFrame(df_percent[['cuisines','Mean Rating', 'cost','location','city']][df_percent.index == each].sample()))
    
    # Drop the same named restaurants and sort only the top 10 by the highest rating
    df_new = df_new.drop_duplicates(subset=['cuisines','Mean Rating', 'cost'], keep=False)
    df_new = df_new.sort_values(by='Mean Rating', ascending=False).head(10)
    
    print('TOP %s RESTAURANTS LIKE %s WITH SIMILAR REVIEWS: ' % (str(len(df_new)), name))
    
    return df_new

"""Pada code cell di bawah ini, kita akan mencari rekomendasi dari resto yang pernah disukai, dalam kasus ini,  resto yang disukai adalah "Jalsa" """

df_percent.head()

"""Pada cell code di bawah ini, kita akan mendapatkan Rekomendasi Resto dari nama resto "Jalsa"
"""

recommendations = recommend('Jalsa')
recommendations

"""### Evaluation

Kita akan memakai metrik evaluasi akurasi di mana akurasi adalah:

Jumlah resto yang direkomendasikan sesuai dengan location resto / Jumlah resto yang direkomendasikan
"""

df_percent.reset_index(inplace=True)

df_percent[df_percent.name == "Jalsa"]

restoname_that_have_been_liked_now  = df_percent[df_percent.location == "Marathahalli"]
restoname_that_have_been_liked_resto_location = restoname_that_have_been_liked_now.iloc[0]["location"]

"""Variabel cuisines merupakan sebuah list yang terdiri dari cuisines dari reviews resto yang direkomendasikan oleh sistem"""

resto_recommendation_location = recommendations['location']

restorecomenfinal = resto_recommendation_location.reset_index()

restolocation = restorecomenfinal.location

restolocation

restoname_that_have_been_liked_resto_location

"""Code di bawah ini merupakan proses manual di mana setiap cuisines dari resto yang direkomendasikan akan dicek, apabila sama, maka variabel real_cuisines akan bertambah 1"""

real_location = 0
for i in range(10):
    if restolocation[i] == restoname_that_have_been_liked_resto_location:
        real_location+=1

"""Code di bawah ini adalah akurasi dari model sistem rekomendasi, di mana Jumlah resto yang direkomendasikan sesuai dengan tipe rresto (Variabel resto_type) / Jumlah resto yang direkomendasikan (5)"""

real_location

Accuracy = real_location/2*100
print("Accuracy of the model is {}%".format(Accuracy))

"""Maka dapat dilihat pada akurasi di atas, model menunjukkan akurasi 100%

**Cek Precision**

Precision pada recomendasion system mempunya rumus : 
![image.png](data:image/png;base64,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)
"""

2/10

"""Dari kode diatas maka presisi yg di dapat yaitu 20%

##Collaborative Filtered Recommendation System

Goal proyek  Collaborative Filtered kali ini adalah menghasilkan rekomendasi sejumlah restoran yang sesuai dengan preferensi pengguna berdasarkan rating yang telah diberikan sebelumnya. Dari data rating pengguna, kita akan mengidentifikasi restoran-restoran yang mirip dan belum pernah dikunjungi oleh pengguna untuk direkomendasikan. Kita akan menggunakan teknik collaborative filtering untuk membuat rekomendasi ini.

Kelebihan pada Collaborative Based Filtering bila dibandingkan dengan Content Based Filtering adalah pengguna dapat mengeksplorasi item atau konten di luar preferensi pengguna. Pengguna pun juga dapat mendapat rekomendasi sesuai dengan kecenderungan publik yang dianalisa lewat penilaian pengguna - pengguna lainnya.

Kekurangan pada Collaborative Based Filtering adalah pengguna kurang mendapatkan rekomendasi sesuai preferensi pribadi. Konten - konten yang diberikan oleh sistem rekomendasi lebih banyak berasal dari preferensi publik dan bukan preferensi pribadi.

**Investor akan mencari rekomendasi restoran yang sesuai preferensi tipe restoran yang dia sukai dengan mengetahui type restoran apa yang ingin dibuka, kemudian sistem akan merekomendasikan restoran serupa dengan inforamasi lokasi dan jenis makanan yang potensial berdasarkan rating terbaik**

###FEATURE ENGINEERING
"""

dfresto

resto_name = dfresto['name'].tolist()
resto_type = dfresto['rest_type'].tolist()
resto_dish_liked = dfresto['dish_liked'].tolist()
resto_cuisines = dfresto['cuisines'].tolist()
resto_location = dfresto['location'].tolist()
resto_city = dfresto['city'].tolist()
resto_address = dfresto['address'].tolist()
resto_rate= dfresto['rate'].tolist()

resto = pd.DataFrame({
    'resto_name': resto_name,
    'resto_type': resto_type,
    'resto_dish_liked': resto_dish_liked,
    'resto_cuisines': resto_cuisines,
    'resto_location': resto_location,
    'resto_city': resto_city,
    'resto_address':resto_address,
    'resto_rate':resto_rate
})
resto.head()

"""####Data Preparation

#####Rubah koma dalam datasetmenjadi &
"""

resto.resto_type  = resto.resto_type.apply(lambda x: x.replace(',',' & '))

"""#####Drop Duplicated"""

resto = resto.drop_duplicates('resto_name')

resto.head()

resto.resto_name.duplicated().sum()

resto.duplicated().sum()

resto.columns

resto.isnull().any() .isnull().sum()

resto.dropna(inplace=True)

resto.isnull().any() .isnull().sum()

"""#####Ubah kolom ke numeric"""

# Ubah kedalam bentuk numerik
encoded_data = LabelEncoder()

resto['resto_type_id'] = encoded_data.fit_transform(resto['resto_type'])
resto['resto_location_id'] = encoded_data.fit_transform(resto['resto_location'])

resto.head()

# scaler = StandardScaler()
# resto['resto_type_id_scale'] = scaler.fit_transform(resto['resto_type_id'].values.reshape(-1,1))
# resto['resto_location_id_scale'] = scaler.fit_transform(resto['resto_location_id'].values.reshape(-1,1))
# resto['resto_rate_scale'] = scaler.fit_transform(resto['resto_rate'].values.reshape(-1,1))
# resto

"""#####Encode Type Restoran"""

# Mengubah resto_type menjadi list tanpa nilai yang sama
resto_types = resto['resto_type_id'].unique().tolist()
print('list resto tipe: ', resto_types)
 
# Melakukan encoding resto_type
resto_to_resto_type_encoded = {x: i for i, x in enumerate(resto_types)}
print('encoded reto tipe : ', resto_to_resto_type_encoded)
 
# Melakukan proses encoding angka ke ke tipe restoran
resto_encoded_to_resto_type = {i: x for i, x in enumerate(resto_types)}
print('encoded angka ke resto_type: ', resto_encoded_to_resto_type)

"""#####Encode fitur Lokasi."""

# Mengubah placeID menjadi list tanpa nilai yang sama
resto_location = resto['resto_location_id'].unique().tolist()
 
# Melakukan proses encoding lokasi
resto_to_resto_location_encoded = {x: i for i, x in enumerate(resto_location)}
 
# Melakukan proses encoding angka ke lokasi
resto_encoded_to_resto_location = {i: x for i, x in enumerate(resto_location)}

"""##### Berikutnya, petakan tiperesto dan location ke dataframe yang berkaitan."""

# Mapping tipe restoran ke dataframe resto
resto['tipe_resto'] = resto['resto_type_id'].map(resto_to_resto_type_encoded)
 
# Mapping placeID ke dataframe resto
resto['lokasi_resto'] = resto['resto_location_id'].map(resto_to_resto_location_encoded)

"""#####cek beberapa hal dalam data seperti jumlah tipe restora, jumlah lokasi, dan mengubah nilai rating menjadi float."""

resto.info()

# Mendapatkan jumlah resto type
num_resto_type = len(resto_to_resto_type_encoded)
print(num_resto_type)
 
# Mendapatkan jumlah lokasi
num_resto_location = len(resto_encoded_to_resto_location)
print(num_resto_location)
 
# Nilai minimum rating
min_rating = min(resto['resto_rate'])
 
# Nilai maksimal rating
max_rating = max(resto['resto_rate'])
 
print('Number of tipe resto: {}, Number of lokasi Resto: {}, Min Rating: {}, Max Rating: {}'.format(
    num_resto_type, num_resto_location, min_rating, max_rating
))

"""#####Membagi Data untuk Training dan Validasi

Acak datanya terlebih dahulu agar distribusinya menjadi random
"""

# Mengacak dataset
resto = resto.sample(frac=1, random_state=42)
resto

"""Selanjutnya, kita bagi data train dan validasi dengan komposisi **80:20**. Namun sebelumnya, kita perlu memetakan (mapping) data tipe resto dan lokasi resto menjadi satu value terlebih dahulu. Lalu, dibuat rating dalam skala 0 sampai 1 agar mudah dalam melakukan proses training. """

# Membuat variabel x untuk mencocokkan data tipe reso dan resto menjadi satu value
x = resto[['tipe_resto', 'lokasi_resto']].values
 
# Membuat variabel y untuk membuat rating dari hasil 
y = resto['resto_rate'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values
 
# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.8 * resto.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)
 
print(x, y)

resto[['tipe_resto', 'lokasi_resto','resto_rate']].max()

resto.shape

"""###Modeling

####Embeding

Pada tahap ini, model menghitung skor kecocokan antara tipe resto dan lokasi resto dengan teknik embedding. Pertama, kita melakukan proses embedding terhadap data tipe resto dan lokasi resto. Selanjutnya, operasi perkalian dot product antara embedding tipe resto dan lokasi resto. Selain itu, kita juga dapat menambahkan bias untuk setiap tipe dan lokasi. Skor kecocokan ditetapkan dalam skala [0,1] dengan fungsi aktivasi sigmoid.

Di sini, kita membuat class RecommenderNet dengan keras Model class.
"""

class RecommenderNet(tf.keras.Model):
 
  # Insialisasi fungsi
  def __init__(self, num_resto_type, num_resto_location, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_resto_type = num_resto_type
    self.num_resto_location = num_resto_location
    self.embedding_size = embedding_size
    self.restotype_embedding = layers.Embedding( # layer embedding tipe resto
        num_resto_type,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.restotype_bias = layers.Embedding(num_resto_type, 1) # layer embedding tipe resto bias
    self.restolocation_embedding = layers.Embedding( # layer embeddings resto location
        num_resto_location,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.restolocation_bias = layers.Embedding(num_resto_location, 1) # layer embedding resto location bias
 
  def call(self, inputs):
    resto_type_vector = self.restotype_embedding(inputs[:,0]) # memanggil layer embedding 1
    resto_type_bias = self.restotype_bias(inputs[:, 0]) # memanggil layer embedding 2
    restolocation_vector = self.restolocation_embedding(inputs[:, 1]) # memanggil layer embedding 3
    restolocation_bias = self.restolocation_bias(inputs[:, 1]) # memanggil layer embedding 4
 
    dot_resto_location = tf.tensordot(resto_type_vector, restolocation_vector, 2) 
 
    x = dot_resto_location + resto_type_bias + restolocation_bias
    
    return tf.nn.sigmoid(x) # activation sigmoid

"""Selanjutnya, lakukan proses compile terhadap model."""

model = RecommenderNet(num_resto_type, num_resto_location, 50) # inisialisasi model
 
# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Model ini menggunakan Binary Crossentropy untuk menghitung loss function, Adam (Adaptive Moment Estimation) sebagai optimizer, dan root mean squared error (RMSE) sebagai metrics evaluation.

####Training & Evaluation
"""

# Memulai training
 
history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 5,
    epochs=20,
    validation_data = (x_val, y_val)
)

"""**Visualisasi Metrik**"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""proses training model cukup smooth dan model konvergen pada epochs sekitar 20. Dari proses ini, kita memperoleh nilai error akhir sebesar sekitar 0.12 dan error pada data validasi sebesar 0.13. Nilai tersebut cukup bagus untuk sistem rekomendasi

####**Mendapatkan Rekomendasi Resto**
"""

resto.head(2)

# Mengambil sample resto type
resto_type_id = resto.resto_type_id.sample(1).iloc[0]
resto_visited_by_user = resto[resto.resto_type_id == resto_type_id]
 
# Operator bitwise (~), bisa diketahui di sini https://docs.python.org/3/reference/expressions.html 
resto_not_visited = resto[~resto['resto_type_id'].isin(resto_visited_by_user.resto_type_id.values)]['resto_type_id'] 
resto_not_visited = list(
    set(resto_not_visited)
    .intersection(set(resto_to_resto_location_encoded.keys()))
)
 
resto_not_visited = [[resto_to_resto_location_encoded.get(x)] for x in resto_not_visited]
resto_encoder = resto_to_resto_type_encoded.get(resto_type_id)
resto_resto_array = np.hstack(
    ([[resto_encoder]] * len(resto_not_visited), resto_not_visited)
)

ratings = model.predict(resto_resto_array).flatten()
 
top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_resto_ids = [
    resto_encoded_to_resto_location.get(resto_not_visited[x][0]) for x in top_ratings_indices
]
 
print('Showing recommendations for resto_type_id: {}'.format(resto_type_id))
print('===' * 9)
print('Resto with high ratings from user')
print('----' * 8)
 
top_resto_user = (
    resto_visited_by_user.sort_values(
        by = 'resto_rate',
        ascending=False
    )
    .head(5)
    .resto_location_id.values
)
 
resto_df_rows = resto[resto['resto_type_id'].isin(top_resto_user)]
# for row in resto_df_rows.sort_values(by='resto_rate',ascending=False).head().itertuples():
#     print(row.resto_name, ':', row.resto_cuisines,'. Rating:', row.resto_rate,'.Resto Type:', row.resto_type,', Location: ',row.resto_location, '. Dish Like:',row.resto_dish_liked)
resto_df_rows.sort_values(by='resto_rate',ascending=False).head()

print('----' * 8)
print('Top 5 resto recommendation')
print('----' * 8)
 
recommended_resto = resto[resto['resto_type_id'].isin(recommended_resto_ids)].head()
# for row in recommended_resto.itertuples():
#     print(row.resto_name, ':', row.resto_cuisines,'Resto Type:', row.resto_type,', Location: ',row.resto_location, '. Dish Like:',row.resto_dish_liked)
recommended_resto.sort_values(by='resto_rate',ascending=False).head()

"""System rekomendasi diatas menampilkan rekomendasi type resto yang belum pernah dikunjungi oleh investor/bukan pilihan investor. dalam kasus ini investor ingin membuka usaha dan mendapatkan rekomendasi sesuai tipe restoran yang dia sukai, maka dapat menggunakan **Showing recommendations for users**.

**Temukan rekomendasi sesuai dengan tipe restoran yang ingin dibuka oleh investor**
"""

# Mengambil sample resto type
resto_type_id = resto.resto_type_id.sample(1).iloc[0]
resto_visited_by_user = resto[resto.resto_type_id == resto_type_id]
 
# Operator bitwise (~), bisa diketahui di sini https://docs.python.org/3/reference/expressions.html 
resto_visited = resto[resto['resto_type_id'].isin(resto_visited_by_user.resto_type_id.values)]['resto_type_id'] 
resto_visited = list(
    set(resto_visited)
    .intersection(set(resto_to_resto_location_encoded.keys()))
)
 
resto_visited = [[resto_to_resto_location_encoded.get(x)] for x in resto_visited]
resto_encoder = resto_to_resto_type_encoded.get(resto_type_id)
resto_resto_array = np.hstack(
    ([[resto_encoder]] * len(resto_visited), resto_visited)
)

ratings = model.predict(resto_resto_array).flatten()
 
top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_resto_ids = [
    resto_encoded_to_resto_location.get(resto_not_visited[x][0]) for x in top_ratings_indices
]
 
print('----' * 8)
print('Top 5 resto recommendation')
print('----' * 8)
 
recommended_resto = resto[resto['resto_type_id'].isin(recommended_resto_ids)].head()
# for row in recommended_resto.itertuples():
#     print(row.resto_name, ':', row.resto_cuisines,'Resto Type:', row.resto_type,', Location: ',row.resto_location, '. Dish Like:',row.resto_dish_liked)
recommended_resto.sort_values(by='resto_rate',ascending=False).head()